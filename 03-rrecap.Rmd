# R recap {#rrecap} 
This section provides a brief recap of the basic steps that are required or useful to do before staring on the project.

## Setting working directory
At the beginning of each project it is crucial to determine the working directory for your project. A working directory is a folder where all your files associated with the project will be stored. For example, original datasets, saved datasets as well as plots, graphs or maps created and exported from R. Hence, working directory not only allows you to gather and access the files produced along the work but also load the existing datasets into the RStudio.<br/><br/>

You can set up the working directory with the `openProject` function as follows (recommended):

```{r, eval=FALSE}
rstudioapi::openProject("path to your directory")
```

Alternatively, you can use the following command:
```{r, eval=FALSE}
setwd("path to your directory")
```

While the former option will set up and open the working directory for your project, the latter simply determines the default folder for each specific R script. 

## Creating, naming and saving a new R script

The R script is a plain text file that allows you to save the R code containing both, commands and comments. Saving the R script allows you to reuse your R code and creates a reproducible record of your work. Therefore, it is a good practice to create, name and save it at the very beginning of your project. <br/><br/>
You can crate a new R script by clicking the **New File** icon in the top right corner of the RStudio toolbar, which will open a list with different file options. Choose the **R Script** from the menu and the blank script will open in the main RStudio window.

<style>
div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;}
</style>
<div class = "yellow">
**Shortcut**: New R script can also be opened by *Shift+Ctrl+N*.
</div>

You can now save your R script by clicking on the Save icon at the top of the **Script Editor**, this will prompt a *Save File* window where you can change the name of your script. Note that the file extension for R scripts is **.R**. At this point you can also choose a folder where to save your new file. By default, RStudio will try to save your new script in the current working directory. Once the name and file location are chosen, simply click the **Save** button.

<style>
div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;}
</style>
<div class = "yellow">
**Shortcut**: As you work along your R script document, you can quickly save changes by pressing *Ctrl+S*.
</div>

## Executing the code
Now, as you set up the working directory for your project and created your first R script file, we will look into ways of executing (also known as running) the code. You can execute selected chunk of code by clicking **Run** button at the top right corner of the **Script Editor**. 

<style>
div.yellow { background-color:#fff5e6; border-radius: 5px; padding: 20px;}
</style>
<div class = "yellow">
**Shortcut**: You can also execute the selected code with  *Ctrl+Enter*.
</div>

If you do not select any code and press **Run**, RStudio will run the line of code where the cursor is located. The code which has been exectued will appear in the **Console**, usually located at the bottom part of the window.

In RStudio it is also possible to add comments next to your commands simply using a hashtag (#) beforehand. This will stop R from executing this specific part:
```{r}
3+6 # Using R as a calculator

# 3+6
```

## Install and load packages

## Load data
There are different approaches that can be used to import your datasets, depending on where the data is located and in what file type it is stored. The easiest case is when the dataset is already part of the R package, as it will be automatically read in when the package is installed and loaded into R.<br/>
For example, install packages containing dataset:
```{r, eval=FALSE}
remotes::install_github("afrimapr/afrilearndata")
```
Load them:
```{r, results='hide', warning=FALSE, message=FALSE}
library(afrilearndata)
```
To view what datasets are available in a given package:
```{r}
data(package="afrilearndata")
```
We can view and explore the `africapitals` dataset using:
```{r, warning=FALSE, message=FALSE}
head(africapitals)
```
We can also create a dataframe from `africapitals` in the global environment:
```{r, warning=FALSE, message=FALSE}
dataset <- africapitals
```

## Basic data types
In this section we explore a basic set of possible object types that you can encounter in a dataframe. The division presented below is based on the types of values that data (object) stores. The most popular data types are:

- Numeric
- Character
- Logical (so-called Boolean)
- Factor

In R the type of object is referred to as `class` of an object and this function can be used to learn what data types the object contains. 
```{r, warning=FALSE, message=FALSE}
x <- 11 #we create a vector that stores value 11
class(x)
```

It is useful because each class has different properties and can be used in a different way. For example, intuitively we can perform the mathematical operations on numeric objects such that:

```{r, warning=FALSE, message=FALSE}
x <- 11 
y <- 52
x*y # multiplication
```

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">
**Hint**: To assign a value to an object two operators can be used interchangeably: `<-` or `=`.
</div>
### Numeric and integer
*Numeric data* stores real numbers. This means that the object `x` from above is in fact 11.000000, where the zeros are not printed, by default. It is also possible to store value as whole number in a class object called `integer`. An integer can be created from a `numeric` object in the following way:

```{r, warning=FALSE, message=FALSE}
x <- 13.5
z <- as.integer(x)
class(z)
```

Please note, even though the numeric value is a decimal number the integer by default rounds downwards, hence both *13.1* and *13.9* will result in integer equal *13*.

### Characters
Character objects store text, usually referred to as a `string`. String can be a letter, word or even a sentence. 

```{r, warning=FALSE, message=FALSE}
x <- "adult" 
y <- "A"
y <- "I have a bicycle."

```

Interestingly, a character can also contain a number, however it will be stored as a text and will not have the same properties as a `numeric` or `integer` object. As a  results, it will not be possible to perform calculation on character objects, even if they contain numbers. This is when `class` function becomes helpful.

```{r, warning=FALSE, message=FALSE}
x <- "5" 
y <- 7
class(x)
class(y)
```

It is also possible to convert character variables into numeric:

```{r, warning=FALSE, message=FALSE}
x <- "5" 
z <- as.numeric(x)
class(z)
```

### Logical
Logical objects can take values `TRUE` or `FALSE`, where `TRUE` is an equivalent of 1 whereas `FALSE` is an equivalent of 0. In these sense, they can be thought of as numerical values.
```{r, warning=FALSE, message=FALSE}
x <- TRUE
y <- 3+TRUE
print(y)
```

Typically, logical objects are results of a condition. For example, if we want to test if object `a` is larger than 100.

```{r, warning=FALSE, message=FALSE}
a <- 76 #create object a
a > 100 # condition 1
a < 80 # condition 2
```

### Factors
Factors are categorical variables with associated `levels`. They can store both, numbers:
```{r, warning=FALSE, message=FALSE}
a <- rep(1:3, times=3) # create a vector of numbers from 1 to 3, repeated 3 times
a <- as.factor(a)
a
```
and strings:
```{r, warning=FALSE, message=FALSE}
b <- c("A", "B", "B", "C", "D", "C", "C")
b <- as.factor(b)
b
```
The numbers and strings, in the example above, serve as labels of different levels.

## Basic objects and data structures
In this section we explain the basic data structures that we often work with in R. These include a vector, list, matrix and a dataframe.

### Vector
Vector is a one dimensional structure which contains elements of the same type. Usually a `combine` function is used to create a vector such that:
```{r, warning=FALSE, message=FALSE}
a <- c(1:10)
```
It is also possible to create a vector with text-based objects, for example with capitals from our `afrilearndata`:
```{r, warning=FALSE, message=FALSE}
capitals <- africapitals$capitalname
```
We can `print` content of our vector to see what it contains:
```{r, warning=FALSE, message=FALSE}
print(capitals)
```
Another important feature is to see what types of objects the vector stores. We can see that our text-based objects are *characters* using `typeof` function:
```{r, warning=FALSE, message=FALSE}
typeof(capitals)
```

### Matrix
Matrix can be though of as an upgraded version of a vector, where vector is an one-dimensional array and two-dimensional array. We can create a matrix that has three columns and five rows with the following:
```{r, warning=FALSE, message=FALSE}
matrix(1:15, ncol=3, nrow=5, byrow = TRUE)
```
By default, the elements in the matrix will be arranged by column, so `byrow=TRUE` segregates the elements in the matrix row-wise.<br/>

We can also exploit the fact that matrix is an upgraded vector by binding them column- or row-wise, as long as they have the same length:
```{r, warning=FALSE, message=FALSE}
vector1 <- c("water", "milk", "juice")
vector2 <- (1:3)
cbind(vector1, vector2) #for row-wise binding we would use rbind()
```

### Data frame
Data frame is a two dimensional array, similar to a matrix. However, it can contain different data types, unlike matrix. Beyond, columns as well as rows within the data frame are named. In a data frame a column is a variable and row is an observation. You can create a simple data frame with two columns and three rows, using vectors above, with `data.frame` function:
```{r, warning=FALSE, message=FALSE}
data.frame(vector1, vector2)
```
If you compare the output of the example above where we used the `cbind` function to create a matrix, to the result of the `data.frame` function, we can clearly see the difference between a matrix and a data frame. Where matrix is homogeneous and data frame is heterogeneous in terms of data type. All the values in the matrix are characters while the first column in data frame contains factors and the second one integers. <br/>

To address a specific column in a data frame we can use *$* such that:
```{r, warning=FALSE, message=FALSE}
df_1 = data.frame(vector1, vector2) #create data frame called df_1
df_1$vector1 #view column called vector1
```
At the moment columns in the *df_1* adapted names of the vectors:
```{r, warning=FALSE, message=FALSE}
colnames(df_1)
```
We can change the column headers by their *names* or their *index* such that:
```{r, warning=FALSE, message=FALSE}
names(df_1)[names(df_1) == "vector1"] <- "drinks"
names(df_1)[2] <- "amount"
colnames(df_1)

```


## Formats of spatial data (content, extensions) 

Given that spatial data is more varied, and each type is specific and usually requires its own package I wonder if we should include it here at all?
